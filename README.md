# BallCollisionSimulation
Overview.

This program mimics two-dimensional multi-ball collisions limited to a rectangular scene. This is achieved by a simple physics simulation. The engine regularly updates the scene with a logic and graphical rendering phase. Within the logic phase, each ball is integrated and updated if collision occurs with the walls or other balls.

Engine functions.

The portions of the engine relevant to this project are the game loop and the vector class. 

After creation of the canvas, the engine calls an abstract ‘first()’ method, used for allowing the user to implement code before the looping method. The game loop maintains the function of ticking (computing logic) and rendering (drawing graphics to the screen). It continuously checks if the appropriate amount of time has passed until the logic should be updated (the inverse of the number of frames per second) and if the frame should be rendered to, and otherwise calls sleep on the thread. If the appropriate amount of time has passed, then the tick() method is called, an abstract method for user implementation of game logic, and ‘changeInTimeSec’ is decremented by ‘secondsPerFrame’, as a single tick has occurred. Since the logic has been updated, the ‘renderToFrame’ flag is set to true so that the graphics will update. If the ‘renderToFrame’ flag is true, then a BufferStrategy is created and a Graphics2D object is associated with the BufferStrategy’s draw graphics. At this point, if the ‘smooth’ flag is set, anti-aliasing is set on for the Graphics2D object. Then the render method is called, an abstract method to be implemented by the user, to draw to the Graphics2D object. ‘renderToFrame’ is set to false as the rendering has occurred, and no logic has been updated to animate. If the frame does not need to be rendered to, this indicates that no tick updates have occurred, so the thread sleeps for 1 millisecond. This helps with increasing efficiency, rather than continuously looping until the next tick.
The aspects of the vector class relative to this project are mostly simple mathematical functions, self-contained and self-describing in the engine class.

Initialization phase.

The initial settings of the balls are created by a nested for loop, iterating through ‘partitionSize’ * ‘partitionSize’ squares in the initial screen and randomly selecting if the current square should hold a ball or not. If selected, a velocity is randomly generated and the ball’s position is randomly generated, within the constraints of the partitioned square, considering the physical size of the ball itself. These balls are added to an ArrayList of CueBall objects.

Implemented game loop.

The loop consists of ticking all balls, rendering a rectangle to the Graphics2D object, then calling each ball’s render method, which draws an oval at the ball’s current position.

User IO.

The program allows for the user to move a single selected ball by clicking near it and releasing the mouse in the desired direction. When the mouse is pressed, the location is stored as a ‘ballPoint’ vector, and the ArrayList of CueBalls is converted to an array, then sorted, and the first ball in the array is stored as ‘selectedBall’. When the mouse is released, a vector is created by subtracting the previous ‘ballPoint’ vector from the ‘newPoint’, effectively pointing in the direction of the new point, and added to the ‘selectedBall’ velocity. Contained in the CueBall integration method is a cap to avoid setting this velocity too high and causing erratic behavior.

CueBall class.

The CueBall contains information about the ball’s velocity, position, color, and size. For each tick, the physics of the ball is updated. If it’s colliding with a wall, the component of its velocity causing the intersection is reflected. Friction is applied by multiplying the velocity by a scalar just shy of 1. The velocity is limited to avoid the user input on the mouse from causing irrationally high ball speeds, but still maintaining differing speeds based on how far the user flicks the ball. This is done by comparing the square of the speed to the vector’s dot product, and if the current magnitude is greater than the square of the speed, then the vector is set equal to itself normalized times the new, smaller speed. The updated position is equal to the position plus the velocity value. Then for each ball instance, the ArrayList of all balls is iterated through and if the current ball is intersecting the other ball and it is not the object itself, then the position is reset by subtracting the current velocity from the ball’s position, to compensate for any interpenetration during the frame, and the velocities are updated. I will now detail how intersections and collisions are handled in their respective methods.

The intersecting method.

A rudimentary method is used for preprocessing. The absolute magnitude of the distance in the x direction between the balls is calculated by subtracting the vectors and taking the absolute value, and similarly for the y direction. Then a buffered distance around the ball is set to two times the sum of the radius of the ball in question and the other ball. If the x distance or y distance is greater than this extended radius from the ball, then the method returns false and doesn’t continue computation. The purpose of this calculation is because rejecting balls that have no chance of colliding with the ball in question by doing simple math on primitive data types speeds up the processing time, whereas the traditional method for collision detection between two balls that I will detail takes a little longer computationally. A better method for this preprocessing would be a more advanced algorithm, like quadtrees, which recursively subdivide the screen into 4 parts and use this to detect if the balls occupy the same leaf, rather than performing a distance check between all balls on the screen. Finally, if the balls are in range of each other, the method returns if the optimized distance between the balls, its dot product, is less than or equal to the square of the sum of the ball’s radiuses. This is computing if the distance between the balls is less than or equal to the distance between the radiuses. The purpose for raising the sum of the radiuses to the power of two, rather than taking the square root of the dot product of the difference vector between the two positions is that raising a number to a power is more efficient than finding the root of a number.

The collision method.

This includes some fun vector math, but follows a rather simple principle. For two balls in an elastic collision, the component of their velocity perpendicular to each other should remain fixed, and the component of the velocity parallel to the collision should swapped. In order to do this, repeat this process for both balls: create a distance vector from the other ball to the current ball. Find the parallel component of this current ball’s velocity by projecting the velocity on this distance vector. Find the perpendicular component by subtracting this parallel component from the current ball’s velocity. Finally, after computing the parallel and perpendicular components of the velocity for both balls, updated each velocity by setting it equal to the perpendicular component of its velocity plus the parallel component of the other velocity.
